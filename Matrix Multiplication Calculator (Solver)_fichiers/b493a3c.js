// Generated by CoffeeScript 1.7.1
(function() {
  var absFunc, arcFunc, arithmeticModule, arithmeticPreprocess, atom, atomHelper, constant, constants, dontTake, greekSymbols, implicitGenerator, implicitMultiplication, integralParser, isArray, keywordParser, lazyParser, leftOperatorExprParser, level1, level1Generator, level1Operator, level2, level2Generator, level2Operator, level2_5, level2_5Generator, level3, level3Generator, list, logFunc, mathFunc, mathFuncs, maybe, orParser, parens, parensAtom, powerOperator, powerParserHelper, realParser, reduce, regExpParser, repeatParser, replaceWordsMapHelper, rightOperatorExprParser, scientific, seqParser, symbols, texArcFunc, texAtom, texFraction, texFuncTransform, texFuncs, texImplicit, texLevel1, texLevel1Op, texLevel2, texLevel2Op, texLevel3, texLevel5, texParens, texUnaryFunc, transformInputText, transformResult, unaryMathFunc, unaryMinus, unaryMinusGenerator, varParser, whiteSpacesContainer,
    __slice = [].slice;

  regExpParser = _pl.regExpParser, seqParser = _pl.seqParser, keywordParser = _pl.keywordParser, transformResult = _pl.transformResult, orParser = _pl.orParser;

  repeatParser = _pl.repeatParser, lazyParser = _pl.lazyParser, realParser = _pl.realParser, rightOperatorExprParser = _pl.rightOperatorExprParser, reduce = _pl.reduce;

  leftOperatorExprParser = _pl.leftOperatorExprParser, transformInputText = _pl.transformInputText, replaceWordsMapHelper = _pl.replaceWordsMapHelper;

  isArray = _pl.isArray, whiteSpacesContainer = _pl.whiteSpacesContainer, integralParser = _pl.integralParser;

  this.arithmeticParsing = {};

  varParser = regExpParser(/^[a-zA-Z]/);

  this.arithmeticParsing.varParser = varParser;

  dontTake = function(parser) {
    return function(status) {
      parser(status);
      return status;
    };
  };

  this.arithmeticParsing.dontTake = dontTake;

  parens = function(child, open, close) {
    if (open == null) {
      open = "(";
    }
    if (close == null) {
      close = ")";
    }
    return (seqParser(keywordParser(open), {
      child: child
    }, keywordParser(close)))(function(result) {
      return result.child;
    });
  };

  this.arithmeticParsing.parens = parens;

  constant = function(symbol) {
    return transformResult(keywordParser(symbol), function(r) {
      var result;
      result = {};
      result[symbol] = [];
      return result;
    });
  };

  this.arithmeticParsing.constant = constant;

  constants = orParser(constant('pi'), constant('e'), transformResult(constant('oo'), function() {
    return {
      'inf': []
    };
  }));

  this.arithmeticParsing.constants = constants;

  unaryMathFunc = function(name, child) {
    var seq;
    seq = seqParser(keywordParser(name), {
      child: child
    });
    return seq(function(result) {
      var func;
      func = {};
      func[name] = [result.child];
      return func;
    });
  };

  this.arithmeticParsing.unaryMathFunc = unaryMathFunc;

  list = function(child, separator) {
    var restEl, seq;
    if (separator == null) {
      separator = ',';
    }
    restEl = (seqParser(keywordParser(separator), {
      el: child
    }))(function(r) {
      return r.el;
    });
    seq = seqParser({
      first: child,
      rest: repeatParser(restEl)
    });
    return seq(function(res) {
      return [res.first].concat(res.rest);
    });
  };

  this.arithmeticParsing.list = list;

  mathFunc = function(name) {
    var seq;
    seq = seqParser(keywordParser(name), {
      args: parens(list(lazyParser(function() {
        return level1;
      })))
    });
    return seq(function(result) {
      var func;
      func = {};
      func[name] = result.args;
      return func;
    });
  };

  this.arithmeticParsing.mathFunc = mathFunc;

  logFunc = transformResult(mathFunc("log"), function(result) {
    var _ref;
    if ((result != null ? (_ref = result.log) != null ? _ref.length : void 0 : void 0) === 1) {
      return {
        ln: result.log
      };
    } else {
      return result;
    }
  });

  absFunc = function(child) {
    var seq;
    seq = seqParser(orParser(keywordParser("Abs"), keywordParser("abs")), {
      child: child
    });
    return seq(function(result) {
      return {
        abs: [result.child]
      };
    });
  };

  arcFunc = function(funcName, child) {
    var seq;
    seq = seqParser(orParser(keywordParser("a" + funcName), keywordParser("arc" + funcName)), {
      child: child
    });
    return seq(function(result) {
      var obj;
      obj = {};
      obj["arc" + funcName] = [result.child];
      return obj;
    });
  };

  this.arithmeticParsing.logFunc = logFunc;

  mathFuncs = function(child) {
    return orParser(unaryMathFunc("exp", child), unaryMathFunc("cosh", child), unaryMathFunc("cos", child), unaryMathFunc("sinh", child), unaryMathFunc("sin", child), unaryMathFunc("tan", child), unaryMathFunc("tg", child), unaryMathFunc("cot", child), unaryMathFunc("ctg", child), unaryMathFunc("sqrt", child), unaryMathFunc("ln", child), arcFunc('cot', child), arcFunc('tan', child), arcFunc('sin', child), arcFunc('cos', child), absFunc(child), logFunc);
  };

  this.arithmeticParsing.mathFuncs = mathFuncs;

  symbols = function() {
    var keywords, list, symbol;
    list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    keywords = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        symbol = list[_i];
        _results.push(keywordParser(symbol));
      }
      return _results;
    })();
    return orParser.apply(null, keywords);
  };

  this.arithmeticParsing.symbols = symbols;

  greekSymbols = symbols("alpha", "beta", "gamma", "delta", "epsilon", "zeta", "theta", "lambda", "omicron", "sigma", "tau", "upsilon", "psi", "omega");

  this.arithmeticParsing.greekSymbols = greekSymbols;

  parensAtom = parens(lazyParser(function() {
    return atom;
  }));

  scientific = function(status) {
    var eKeyword, minusIntegral, parser, power, seq;
    eKeyword = orParser(keywordParser("e"), keywordParser("E"));
    minusIntegral = (seqParser(keywordParser("-"), {
      p: integralParser
    }))(function(r) {
      return r.p * (-1);
    });
    power = orParser(integralParser, minusIntegral);
    seq = seqParser({
      base: realParser
    }, eKeyword, {
      power: power
    });
    parser = seq(function(result) {
      return result.base * Math.pow(10, result.power);
    });
    return parser(status);
  };

  this.arithmeticParsing.scientific = scientific;

  atomHelper = orParser(scientific, realParser, mathFuncs(lazyParser(function() {
    return orParser(parensAtom, level2_5);
  })), greekSymbols, constants, varParser, parens(lazyParser(function() {
    return level1;
  })));

  atom = whiteSpacesContainer(atomHelper);

  this.arithmeticParsing.atom = atom;

  powerOperator = orParser(keywordParser("^"), transformResult(keywordParser("**"), function(r) {
    return "^";
  }));

  powerParserHelper = function() {
    var seq;
    seq = seqParser(powerOperator, {
      expr: rightOperatorExprParser(powerOperator, orParser(atom, lazyParser(function() {
        return unaryMinus;
      })))
    });
    return seq(function(result) {
      return result.expr;
    });
  };

  level3Generator = function(atom) {
    return function(status) {
      var atomStatus, e, helperStatus;
      atomStatus = atom(status);
      try {
        helperStatus = powerParserHelper()(atomStatus);
        return helperStatus.withNewResult({
          '^': [atomStatus.result, helperStatus.result]
        });
      } catch (_error) {
        e = _error;
        return atomStatus;
      }
    };
  };

  this.arithmeticParsing.level3Generator = level3Generator;

  level3 = level3Generator(atom);

  this.arithmeticParsing.level3 = level3;

  implicitGenerator = function(level3) {
    return transformResult(repeatParser(level3), function(result) {
      var start;
      if ((isArray(result)) && (result.length > 0)) {
        start = result.shift();
        return reduce(result, start, function(acc, element) {
          return {
            '*': [acc, element]
          };
        });
      } else {
        throw "couldn't parse implicit multiplication";
      }
    });
  };

  implicitMultiplication = implicitGenerator(level3);

  this.arithmeticParsing.implicitMultiplication = implicitMultiplication;

  unaryMinusGenerator = function(implicitMultiplication) {
    return (seqParser(keywordParser("-"), {
      level3: implicitMultiplication
    }))(function(result) {
      if (((result != null ? result.level3 : void 0) != null) && (typeof result.level3 !== "number")) {
        return {
          unary_minus: [result.level3]
        };
      } else {
        return result.level3 * (-1);
      }
    });
  };

  unaryMinus = unaryMinusGenerator(implicitMultiplication);

  level2_5Generator = function(level3) {
    var implicit;
    implicit = implicitGenerator(level3);
    return orParser(unaryMinusGenerator(implicit), implicit);
  };

  this.arithmeticParsing.level2_5Generator = level2_5Generator;

  level2_5 = orParser(unaryMinus, implicitMultiplication);

  this.arithmeticParsing.level2_5 = level2_5;

  level2Generator = function(level2_5) {
    return leftOperatorExprParser(level2Operator, level2_5);
  };

  this.arithmeticParsing.level2Generator = level2Generator;

  level2Operator = orParser(keywordParser("*"), keywordParser("/"), transformResult(keywordParser(":"), function(r) {
    return "/";
  }));

  level2 = level2Generator(level2_5);

  this.arithmeticParsing.level2 = level2;

  level1Generator = function(level2) {
    return leftOperatorExprParser(level1Operator, level2);
  };

  this.arithmeticParsing.level1Generator = level1Generator;

  level1Operator = orParser(keywordParser("+"), keywordParser("-"));

  level1 = level1Generator(level2);

  this.arithmeticParsing.level1 = level1;

  arithmeticPreprocess = function(text) {
    var f1;
    f1 = replaceWordsMapHelper({
      'plus': '+',
      'minus': '-',
      'times': '*',
      'mult': '*',
      'power': '^',
      'by': '/',
      'div': '/'
    });
    return f1(text);
  };

  this.arithmeticParsing.arithmeticPreprocess = arithmeticPreprocess;

  this.arithmeticParsing.arithmetic = transformInputText(level1, arithmeticPreprocess);

  this._ap = this.arithmeticParsing;

  if (typeof angular !== "undefined" && angular !== null) {
    arithmeticModule = angular.module('calculArithmeticParsingModule', []);
    arithmeticModule.factory('calculParserLib', function() {
      return _pl;
    });
    arithmeticModule.factory('calculArithmeticParsing', (function(_this) {
      return function() {
        return _this.arithmeticParsing;
      };
    })(this));
  }

  this.LatexParsing = {};

  this._lp = this.LatexParsing;

  texParens = function(child) {
    return orParser(parens(child), parens(child, "{", "}"), parens(child, "\\left(", "\\right)"));
  };

  maybe = function(parser) {
    return function(status) {
      var error;
      try {
        return parser(status.withNewResult({}));
      } catch (_error) {
        error = _error;
        return status;
      }
    };
  };

  texFuncTransform = function(func) {
    var seq;
    seq = seqParser(maybe(keywordParser('\\')), {
      res: func
    });
    return seq(function(result) {
      return result.res;
    });
  };

  texUnaryFunc = function(name, child) {
    return texFuncTransform(unaryMathFunc(name, child));
  };

  texArcFunc = function(name, child) {
    return texFuncTransform(arcFunc(name, child));
  };

  texFuncs = function(child) {
    return orParser(texUnaryFunc("exp", child), texUnaryFunc("cosh", child), texUnaryFunc("cos", child), texUnaryFunc("sinh", child), texUnaryFunc("sin", child), texUnaryFunc("tan", child), texUnaryFunc("tg", child), texUnaryFunc("cot", child), texUnaryFunc("ctg", child), texUnaryFunc("sqrt", child), texUnaryFunc("ln", child), texArcFunc('cot', child), texArcFunc('tan', child), texArcFunc('sin', child), texArcFunc('cos', child), texFuncTransform(absFunc(child)), texFuncTransform(logFunc));
  };

  texAtom = orParser(realParser, texFuncs(lazyParser(function() {
    return orParser(texParens(texAtom), texLevel3);
  })), varParser, texParens(lazyParser(function() {
    return texLevel1;
  })));

  texLevel5 = rightOperatorExprParser(keywordParser('^'), texAtom);

  texFraction = function(child) {
    return (seqParser(keywordParser('\\frac'), {
      a: texParens(child)
    }, {
      b: texParens(child)
    }))(function(result) {
      return {
        '/': [result.a, result.b]
      };
    });
  };

  texImplicit = implicitGenerator(orParser(texLevel5, texFraction(lazyParser(function() {
    return texLevel1;
  }))));

  texLevel3 = orParser(unaryMinusGenerator(texImplicit), texImplicit);

  texLevel2Op = transformResult(orParser(keywordParser('*'), keywordParser('\\cdot')), function(r) {
    return '*';
  });

  texLevel2 = leftOperatorExprParser(texLevel2Op, texLevel3);

  texLevel1Op = orParser(keywordParser('+'), keywordParser('-'));

  texLevel1 = leftOperatorExprParser(texLevel1Op, texLevel2);

  this.LatexParsing.texLevel1 = texLevel1;

  this.LatexParsing.latexParser = LatexParsing.texLevel1;

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  var Printer, getOp, isNumber, isOperation, isVariable, latexPrinter, makeLatexPrinter, makePlainTextPrinter, plainTextPrinter, printersModule, trigFunctions,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Printer = (function() {
    function Printer() {
      this.print = __bind(this.print, this);
      this.addOperator = __bind(this.addOperator, this);
      this.setNumberHandler(function(x) {
        return x;
      });
      this.setVariableHandler(function(x) {
        return x;
      });
      this.operators = {};
    }

    Printer.prototype.addOperator = function(op, func) {
      return this.operators[op] = func;
    };

    Printer.prototype.setNumberHandler = function(numberHandler) {
      this.numberHandler = numberHandler;
    };

    Printer.prototype.setVariableHandler = function(variableHandler) {
      this.variableHandler = variableHandler;
    };

    Printer.prototype.print = function(input) {
      var func, getArgs, getOp, isNumber, isOperation, isVariable;
      isOperation = function(input) {
        return (typeof input) === "object";
      };
      isNumber = function(input) {
        return (typeof input) === "number";
      };
      isVariable = function(input) {
        return (typeof input) === "string";
      };
      if (isNumber(input)) {
        return this.numberHandler(input);
      } else if (isVariable(input)) {
        return this.variableHandler(input);
      } else if (isOperation(input)) {
        getOp = function(input) {
          var i;
          for (i in input) {
            return i;
          }
        };
        getArgs = function(input) {
          var op;
          op = getOp(input);
          return input[op];
        };
        if ((func = this.operators[getOp(input)]) && (typeof func) === "function") {
          return func(getArgs(input), getOp(input));
        }
      }
    };

    return Printer;

  })();

  this._printer = {};

  this._printer.LatexPrinter = Printer;

  this._printer.PlainTextPrinter = Printer;

  if (typeof angular !== "undefined" && angular !== null) {
    printersModule = angular.module('calculPrinters', []);
    printersModule.factory('calculPrinter', (function(_this) {
      return function() {
        return _this._printer;
      };
    })(this));
  }

  isOperation = function(input) {
    return (typeof input) === "object";
  };

  isNumber = function(input) {
    return (typeof input) === "number";
  };

  isVariable = function(input) {
    return (typeof input) === "string";
  };

  getOp = function(input) {
    var i;
    for (i in input) {
      return i;
    }
  };

  trigFunctions = ["sin", "cos", "tan", "cot", "csc", "sec", "sinh", "cosh", "tanh", "coth", "ln", "arcsin", "arccos", "arctan", "arccot"];

  makeLatexPrinter = function() {
    var isNegativeFrac, isUnaryMinus, latexPrinter, lessThanZero, parenthesize, printLatex, _i, _len, _op;
    latexPrinter = new _printer.LatexPrinter;
    parenthesize = function(x) {
      return "\\left(" + x + "\\right)";
    };
    lessThanZero = function(arg) {
      return (typeof arg) === 'number' && arg < 0;
    };
    isNegativeFrac = function(args) {
      return lessThanZero(args[0]) || lessThanZero(args[1]);
    };
    isUnaryMinus = function(arg) {
      return (arg.unary_minus != null) || ((arg['/'] != null) && isNegativeFrac(arg['/'])) || ((typeof arg) === 'number' && arg < 0);
    };
    printLatex = latexPrinter.print;
    for (_i = 0, _len = trigFunctions.length; _i < _len; _i++) {
      _op = trigFunctions[_i];
      latexPrinter.addOperator(_op, function(args, op) {
        return "\\" + op + parenthesize(printLatex(args[0]));
      });
    }
    latexPrinter.addOperator('log', function(args) {
      return ("\\log_{" + (printLatex(args[0])) + "}") + parenthesize(printLatex(args[1]));
    });
    latexPrinter.addOperator('e', function() {
      return "\\mathrm{e}";
    });
    latexPrinter.addOperator('pi', function() {
      return "{\\pi}";
    });
    latexPrinter.addOperator('inf', function() {
      return "{\\infty}";
    });
    latexPrinter.addOperator('+', function(args) {
      if (isUnaryMinus(args[1])) {
        return printLatex(args[0]) + ' + ' + parenthesize(printLatex(args[1]));
      } else {
        return printLatex(args[0]) + ' + ' + printLatex(args[1]);
      }
    });
    latexPrinter.addOperator('-', function(args) {
      if (isUnaryMinus(args[1])) {
        return printLatex(args[0]) + ' - ' + parenthesize(printLatex(args[1]));
      } else {
        return printLatex(args[0]) + ' - ' + printLatex(args[1]);
      }
    });
    latexPrinter.addOperator('/', function(args) {
      if (isNegativeFrac(args)) {
        return "-\\frac{" + (printLatex(Math.abs(args[0]))) + "}{" + (printLatex(Math.abs(args[1]))) + "}";
      } else {
        return "\\frac{" + (printLatex(args[0])) + "}{" + (printLatex(args[1])) + "}";
      }
    });
    latexPrinter.addOperator('sqrt', function(args) {
      return "\\sqrt{" + (printLatex(args[0])) + "}";
    });
    latexPrinter.addOperator('abs', function(args) {
      return "\\left|" + (printLatex(args[0])) + "\\right|";
    });
    latexPrinter.addOperator('exp', function(args) {
      return "\\mathrm{e}^{" + (printLatex(args[0])) + "}";
    });
    latexPrinter.addOperator('unary_minus', function(args) {
      var maybeParenthesize;
      maybeParenthesize = function(input) {
        var _ref;
        if (isOperation(input) && ((_ref = getOp(input)) === '+' || _ref === '-')) {
          return parenthesize(printLatex(input));
        }
        return printLatex(input);
      };
      return "-" + maybeParenthesize(args[0]);
    });
    latexPrinter.addOperator('binom', function(args) {
      return "\\binom{" + (printLatex(args[0])) + "}{" + (printLatex(args[1])) + "}";
    });
    latexPrinter.addOperator('^', function(args) {
      var maybeParenthesize;
      maybeParenthesize = function(input) {
        var _ref;
        if (isOperation(input) && ((_ref = getOp(input)) === '+' || _ref === '-' || _ref === '*' || _ref === '^' || _ref === '/' || _ref === 'unary_minus') || input < 0) {
          return parenthesize(printLatex(input));
        } else {
          return printLatex(input);
        }
      };
      return "{" + (maybeParenthesize(args[0])) + "}^{" + (printLatex(args[1])) + "}";
    });
    latexPrinter.addOperator('*', function(args) {
      var getOperatorForMultiplication, maybeParenthesize, maybeParenthesize2;
      getOperatorForMultiplication = function() {
        var getArgs, isHelper, isLeftmost, isMultiplication, isNumOrPower, isRightmost, _isLeftmost, _isRightmost;
        getArgs = function(input) {
          var op;
          op = getOp(input);
          return input[op];
        };
        isNumOrPower = function(input) {
          return isNumber(input) || isOperation(input) && getOp(input) === '^' && isNumber((getArgs(input))[0]);
        };
        isMultiplication = function(input) {
          return isOperation(input) && getOp(input) === '*';
        };
        isHelper = function(i) {
          return function(input) {
            return isNumOrPower(input) || isMultiplication(input) && (isHelper(i))((getArgs(input))[i]);
          };
        };
        isLeftmost = isHelper(0);
        isRightmost = isHelper(1);
        _isRightmost = function(input) {
          return isRightmost(input[0]) && isNumOrPower(input[1]);
        };
        _isLeftmost = (function(_this) {
          return function(input) {
            return isLeftmost(input[1]) && isNumOrPower(input[0]);
          };
        })(this);
        if (_isRightmost(args) || _isLeftmost(args) || isRightmost(args[0]) && isLeftmost(args[1])) {
          return '{\\times}';
        } else {
          return '';
        }
      };
      maybeParenthesize = function(input) {
        var result, _ref;
        result = printLatex(input);
        if (isOperation(input) && ((_ref = getOp(input)) === '+' || _ref === '-')) {
          return parenthesize(result);
        } else {
          return result;
        }
      };
      maybeParenthesize2 = function(input) {
        var _ref;
        if (isOperation(input) && ((_ref = getOp(input)) === 'unary_minus') || input < 0) {
          return parenthesize(printLatex(input));
        }
        return maybeParenthesize(input);
      };
      return maybeParenthesize(args[0]) + getOperatorForMultiplication() + maybeParenthesize2(args[1]);
    });
    latexPrinter.setNumberHandler(function(input) {
      var exponent, round, temp;
      if (input !== 0 && Math.abs(input) < Math.pow(10, -6)) {
        temp = input;
        exponent = 0;
        while (temp < 1) {
          temp *= 10;
          exponent--;
        }
        round = function(num, precision) {
          if (precision == null) {
            precision = 10;
          }
          return Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision);
        };
        return this.print({
          '*': [
            round(temp), {
              '^': [10, exponent]
            }
          ]
        });
      } else {
        return input;
      }
    });
    return latexPrinter;
  };

  latexPrinter = makeLatexPrinter();

  this._printer.makeLatexPrinter = makeLatexPrinter;

  this._printer.latexPrinter = latexPrinter;

  this._printer.print = function(input, printer) {
    if (printer == null) {
      printer = latexPrinter;
    }
    return printer.print(input);
  };

  this.displayLatex = function(input, printer) {
    return latexPrinter.print(input, printer);
  };

  makePlainTextPrinter = function() {
    var parenthesize, plainTextPrinter, print, _i, _len, _op;
    plainTextPrinter = new _printer.PlainTextPrinter;
    parenthesize = function(x) {
      return "(" + x + ")";
    };
    print = plainTextPrinter.print;
    for (_i = 0, _len = trigFunctions.length; _i < _len; _i++) {
      _op = trigFunctions[_i];
      plainTextPrinter.addOperator(_op, function(args, op) {
        return op + parenthesize(print(args[0]));
      });
    }
    plainTextPrinter.addOperator('log', function(args) {
      return "log(" + (print(args[0])) + ", " + (print(args[1])) + ")";
    });
    plainTextPrinter.addOperator('e', function() {
      return "e";
    });
    plainTextPrinter.addOperator('pi', function() {
      return "pi";
    });
    plainTextPrinter.addOperator('inf', function() {
      return "inf";
    });
    plainTextPrinter.addOperator('+', function(args) {
      return print(args[0]) + ' + ' + print(args[1]);
    });
    plainTextPrinter.addOperator('-', function(args) {
      var _ref;
      if (isOperation(args[1]) && ((_ref = getOp(args[1])) === '+' || _ref === '-' || _ref === '/' || _ref === 'unary_minus') || args[1] < 0) {
        return print(args[0]) + ' - ' + parenthesize(print(args[1]));
      }
      return print(args[0]) + ' - ' + print(args[1]);
    });
    plainTextPrinter.addOperator('/', function(args) {
      var _ref;
      if (isOperation(args[1]) && ((_ref = getOp(args[1])) === '/' || _ref === '*') || args[1] < 0) {
        return print(args[0]) + '/' + parenthesize(print(args[1]));
      }
      return "" + (print(args[0])) + "/" + (print(args[1]));
    });
    plainTextPrinter.addOperator('sqrt', function(args) {
      return "sqrt(" + (print(args[0])) + ")";
    });
    plainTextPrinter.addOperator('abs', function(args) {
      return "|" + (print(args[0])) + "|";
    });
    plainTextPrinter.addOperator('exp', function(args) {
      return "e^" + (print(args[0]));
    });
    plainTextPrinter.addOperator('unary_minus', function(args) {
      var maybeParenthesize;
      maybeParenthesize = function(input) {
        var _ref;
        if (isOperation(input) && ((_ref = getOp(input)) === '+' || _ref === '-' || _ref === '/')) {
          return parenthesize(print(input));
        }
        return print(input);
      };
      return "-" + maybeParenthesize(args[0]);
    });
    plainTextPrinter.addOperator('binom', function(args) {
      return "binom(" + (print(args[0])) + ", " + (print(args[1])) + ")";
    });
    plainTextPrinter.addOperator('^', function(args) {
      var maybeParenthesizeLeft, maybeParenthesizeRight;
      maybeParenthesizeLeft = function(input) {
        var _ref;
        if (isOperation(input) && ((_ref = getOp(input)) === '+' || _ref === '-' || _ref === '*' || _ref === '/' || _ref === '^' || _ref === 'unary_minus') || input < 0) {
          return parenthesize(print(input));
        } else {
          return print(input);
        }
      };
      maybeParenthesizeRight = function(input) {
        var _ref;
        if (isOperation(input) && ((_ref = getOp(input)) === '+' || _ref === '-' || _ref === '*' || _ref === '/')) {
          return parenthesize(print(input));
        } else {
          return print(input);
        }
      };
      return "" + (maybeParenthesizeLeft(args[0])) + "^" + (maybeParenthesizeRight(args[1]));
    });
    plainTextPrinter.addOperator('*', function(args) {
      var getOperatorForMultiplication, left, right, shouldParenthesizeLeft, _ref, _ref1, _ref2;
      getOperatorForMultiplication = function() {
        var getArgs, isDiv, isHelper, isLeftmost, isMultOrDiv, isNumOrPower, isRightmost, _isLeftmost, _isRightmost;
        getArgs = function(input) {
          var op;
          op = getOp(input);
          return input[op];
        };
        isNumOrPower = function(input) {
          return isNumber(input) || isOperation(input) && getOp(input) === '^' && isNumber((getArgs(input))[0]);
        };
        isMultOrDiv = function(input) {
          var _ref;
          return isOperation(input) && ((_ref = getOp(input)) === '*' || _ref === '/');
        };
        isHelper = function(i) {
          var func;
          func = function(input) {
            return isNumOrPower(input) || isMultOrDiv(input) && func((getArgs(input))[i]);
          };
          return func;
        };
        isLeftmost = isHelper(0);
        isRightmost = isHelper(1);
        _isRightmost = function(input) {
          return isRightmost(input[0]) && isNumOrPower(input[1]);
        };
        _isLeftmost = function(input) {
          return isLeftmost(input[1]) && isNumOrPower(input[0]);
        };
        isDiv = function(input) {
          return isOperation(input) && getOp(input) === '/';
        };
        if (_isRightmost(args) || _isLeftmost(args) || isRightmost(args[0]) && isLeftmost(args[1]) || isDiv(args[0])) {
          return '*';
        } else {
          return '';
        }
      };
      shouldParenthesizeLeft = isOperation(args[0]) && ((_ref = getOp(args[0])) === '+' || _ref === '-');
      left = print(args[0]);
      if (shouldParenthesizeLeft) {
        left = parenthesize(left);
      }
      right = print(args[1]);
      if (!shouldParenthesizeLeft && isOperation(args[1]) && ((_ref1 = getOp(args[1])) === '/')) {
        right = parenthesize(print(right));
      } else if (isOperation(args[1]) && ((_ref2 = getOp(args[1])) === 'unary_minus' || _ref2 === '+' || _ref2 === '-') || args[1] < 0) {
        right = parenthesize(print(right));
      }
      return left + getOperatorForMultiplication() + right;
    });
    plainTextPrinter.setNumberHandler(function(input) {
      var exponent, round, temp;
      if (input !== 0 && Math.abs(input) < Math.pow(10, -6)) {
        temp = input;
        exponent = 0;
        while (temp < 1) {
          temp *= 10;
          exponent--;
        }
        round = function(num, precision) {
          if (precision == null) {
            precision = 10;
          }
          return Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision);
        };
        return this.print({
          '*': [
            round(temp), {
              '^': [10, exponent]
            }
          ]
        });
      } else {
        return input;
      }
    });
    return plainTextPrinter;
  };

  plainTextPrinter = makePlainTextPrinter();

  this._printer.plainTextPrinter = plainTextPrinter;

  this._printer.printPlainText = (function(_this) {
    return function(input) {
      return _this._printer.plainTextPrinter.print(input);
    };
  })(this);

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var Evaluator, arithmetic, checkArity, constantFunction, generateBinaryFunction, generateNumberEvalBinaryFunction, isArray, keys, keysHelper, toAngles, toRadians, unaryNumberEvalFunctionGenerator,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.arithmeticEval = {};

  this._aeval = this.arithmeticEval;

  keysHelper = function(obj) {
    var key, keys, val;
    keys = [];
    for (key in obj) {
      val = obj[key];
      keys.push(key);
    }
    return keys;
  };

  keys = function(obj) {
    if ((typeof Object !== "undefined" && Object !== null ? Object.keys : void 0) != null) {
      return Object.keys(obj);
    } else {
      return keysHelper(obj);
    }
  };

  isArray = function(something) {
    if ((typeof Array !== "undefined" && Array !== null ? Array.isArray : void 0) != null) {
      return Array.isArray(something);
    } else {
      return Object.prototype.toString.call(something) === "[object Array]";
    }
  };

  this.arithmeticEval.isArray = isArray;

  Evaluator = (function() {
    function Evaluator() {
      this.evalMap = __bind(this.evalMap, this);
      this.evalFunction = __bind(this.evalFunction, this);
      this.evalObject = __bind(this.evalObject, this);
      this.evalArray = __bind(this.evalArray, this);
      this["eval"] = __bind(this["eval"], this);
      this.addFunction = __bind(this.addFunction, this);
      this.functions = {};
    }

    Evaluator.prototype.addFunction = function(name, func) {
      return this.functions[name] = func;
    };

    Evaluator.prototype["eval"] = function(expr) {
      if (isArray(expr)) {
        return this.evalArray(expr);
      } else if ((typeof expr) === "object") {
        return this.evalObject(expr);
      } else {
        return expr;
      }
    };

    Evaluator.prototype.evalArray = function(expr) {
      var element, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = expr.length; _i < _len; _i++) {
        element = expr[_i];
        _results.push(this["eval"](element));
      }
      return _results;
    };

    Evaluator.prototype.evalObject = function(expr) {
      if (keys(expr).length === 1) {
        return this.evalFunction(expr);
      } else {
        return this.evalMap(expr);
      }
    };

    Evaluator.prototype.evalFunction = function(expr) {
      var name, _ref;
      name = keys(expr).pop();
      if (((_ref = this.functions) != null ? _ref[name] : void 0) != null) {
        return this.functions[name](expr[name]);
      } else {
        return this.evalMap(expr);
      }
    };

    Evaluator.prototype.evalMap = function(expr) {
      var key, result, value;
      result = {};
      for (key in expr) {
        value = expr[key];
        result[key] = this["eval"](value);
      }
      return result;
    };

    return Evaluator;

  })();

  this.arithmeticEval.Evaluator = Evaluator;

  arithmetic = new Evaluator();

  this.arithmeticEval.arithmetic = arithmetic;

  checkArity = function(args, n) {
    return isArray(args) && args.length === n;
  };

  generateBinaryFunction = function(childFunc) {
    return function(args) {
      if (checkArity(args, 2)) {
        return childFunc.apply(null, args);
      } else {
        throw "Expected exactly 2 arguments";
      }
    };
  };

  generateNumberEvalBinaryFunction = function(name, childFunc) {
    return generateBinaryFunction(function(a, b) {
      var result;
      a = arithmetic["eval"](a);
      b = arithmetic["eval"](b);
      if ((typeof a) === "number" && (typeof b) === "number") {
        return childFunc(a, b);
      } else {
        result = {};
        result[name] = [a, b];
        return result;
      }
    });
  };

  arithmetic.addFunction('+', generateNumberEvalBinaryFunction('+', function(a, b) {
    return a + b;
  }));

  arithmetic.addFunction('-', generateNumberEvalBinaryFunction('-', function(a, b) {
    return a - b;
  }));

  arithmetic.addFunction('*', generateNumberEvalBinaryFunction('*', function(a, b) {
    return a * b;
  }));

  arithmetic.addFunction('/', generateNumberEvalBinaryFunction('/', function(a, b) {
    return a / b;
  }));

  arithmetic.addFunction('^', generateNumberEvalBinaryFunction('^', function(a, b) {
    return Math.pow(a, b);
  }));

  arithmetic.addFunction('log', generateNumberEvalBinaryFunction('log', function(a, b) {
    return (Math.log(b)) / (Math.log(a));
  }));

  unaryNumberEvalFunctionGenerator = function(name, childFunc) {
    return function(args) {
      var a, result;
      if (checkArity(args, 1)) {
        a = arithmetic["eval"](args[0]);
        if ((typeof a) === "number") {
          return childFunc(a);
        } else {
          result = {};
          result[name] = a;
          return result;
        }
      } else {
        throw "Expected exactly 1 argument";
      }
    };
  };

  toRadians = function(value) {
    return (value * Math.PI) / 180;
  };

  toAngles = function(value) {
    return (value * 180) / Math.PI;
  };

  arithmetic.addFunction('tan', unaryNumberEvalFunctionGenerator('tan', function(a) {
    return Math.tan(toRadians(a));
  }));

  arithmetic.addFunction('cot', unaryNumberEvalFunctionGenerator('cot', function(a) {
    return 1 / Math.tan(toRadians(a));
  }));

  arithmetic.addFunction('sin', unaryNumberEvalFunctionGenerator('sin', function(a) {
    return Math.sin(toRadians(a));
  }));

  arithmetic.addFunction('cos', unaryNumberEvalFunctionGenerator('cos', function(a) {
    return Math.cos(toRadians(a));
  }));

  arithmetic.addFunction('sqrt', unaryNumberEvalFunctionGenerator('sqrt', function(a) {
    return Math.sqrt(a);
  }));

  arithmetic.addFunction('atan', unaryNumberEvalFunctionGenerator('atan', function(a) {
    return toAngles(Math.atan(a));
  }));

  arithmetic.addFunction('acot', unaryNumberEvalFunctionGenerator('acot', function(a) {
    return toAngles(Math.atan(1 / a));
  }));

  arithmetic.addFunction('asin', unaryNumberEvalFunctionGenerator('asin', function(a) {
    return toAngles(Math.asin(a));
  }));

  arithmetic.addFunction('acos', unaryNumberEvalFunctionGenerator('acos', function(a) {
    return toAngles(Math.acos(a));
  }));

  arithmetic.addFunction('ln', unaryNumberEvalFunctionGenerator('ln', function(a) {
    return Math.log(a);
  }));

  arithmetic.addFunction('unary_minus', unaryNumberEvalFunctionGenerator('unary_minus', function(a) {
    return a * (-1);
  }));

  arithmetic.addFunction('exp', unaryNumberEvalFunctionGenerator('exp', function(a) {
    return Math.exp(a);
  }));

  constantFunction = function(value) {
    return function(args) {
      return value;
    };
  };

  arithmetic.addFunction('e', constantFunction(Math.E));

  arithmetic.addFunction('pi', constantFunction(Math.PI));

}).call(this);

/********************************************************************
 *	Kalendae, a framework agnostic javascript date picker           *
 *	Copyright(c) 2013 Jarvis Badgley (chipersoft@gmail.com)         *
 *	http://github.com/ChiperSoft/Kalendae                           *
 *	Version 0.5.0                                                   *
 ********************************************************************/

(function (undefined) {

var today, moment;

var Kalendae = function (targetElement, options) {
	if (typeof document.addEventListener !== 'function' && !util.isIE8()) return;

	//if the first argument isn't an element and isn't a string, assume that it is the options object
	var is_element = false;
	try {
		is_element = targetElement instanceof Element;
	}
	catch (err) {
		is_element = !!targetElement && is_element.nodeType === 1;
	}
	if (!(is_element || typeof(targetElement) === 'string')) options = targetElement;

	var self = this,
		classes = self.classes,
		opts = self.settings = util.merge(self.defaults, {attachTo:targetElement}, options || {}),
		$container = self.container = util.make('div', {'class':classes.container}),
		calendars = self.calendars = [],
		startDay = moment().day(opts.weekStart),
		vsd,
		columnHeaders = [],
		$cal,
		$title,
		$caption,
		$header,
		$days, $week, dayNodes = [],
		$span,
		i = 0,
		j = opts.months;

	if (util.isIE8()) util.addClassName($container, 'ie8');

	//generate the column headers (Su, Mo, Tu, etc)
	i = 7;
	while (i--) {
		columnHeaders.push( startDay.format(opts.columnHeaderFormat) );
		startDay.add('days',1);
	}

	//setup publish/subscribe and apply any subscriptions passed in settings
	MinPubSub(self);
	if (typeof opts.subscribe === 'object') {
		for (i in opts.subscribe) if (opts.subscribe.hasOwnProperty(i)) {
			self.subscribe(i, opts.subscribe[i]);
		}
	}

	//process default selected dates
	self._sel = [];
	if (!!opts.selected) self.setSelected(opts.selected, false);

	//set the view month
	if (!!opts.viewStartDate) {
		vsd = moment(opts.viewStartDate, opts.format);
	} else if (self._sel.length > 0) {
		vsd = moment(self._sel[0]);
	} else {
		vsd = moment();
	}
	self.viewStartDate = vsd.date(1);

	var viewDelta = ({
		'past'          : opts.months-1,
		'today-past'    : opts.months-1,
		'any'           : opts.months>2?Math.floor(opts.months/2):0,
		'today-future'  : 0,
		'future'        : 0
	})[this.settings.direction];


	if (viewDelta && moment().month()==moment(self.viewStartDate).month()){
		self.viewStartDate = moment(self.viewStartDate).subtract({M:viewDelta}).date(1);
	}


	if (typeof opts.blackout === 'function') {
		self.blackout = opts.blackout;
	} else if (!!opts.blackout) {
		var bdates = parseDates(opts.blackout, opts.parseSplitDelimiter, opts.format);
		self.blackout = function (input) {
			input = moment(input).startOf('day').yearDay();
			if (input < 1 || !self._sel) return false;
			var i = bdates.length;
			while (i--) if (bdates[i].startOf('day').yearDay() === input) return true;
			return false;
		};
	} else {
		self.blackout = function () {return false;};
	}


	self.direction = self.directions[opts.direction] ? self.directions[opts.direction] : self.directions['any'];


	//for the total months setting, generate N calendar views and add them to the container
	j = Math.max(opts.months,1);
	while (j--) {
		$cal = util.make('div', {'class':classes.calendar}, $container);

		$cal.setAttribute('data-cal-index', j);
		if (opts.months > 1) {
			if (j == Math.max(opts.months-1,1)) util.addClassName($cal, classes.monthFirst);
			else if (j === 0) util.addClassName($cal, classes.monthLast);
			else util.addClassName($cal, classes.monthMiddle);
		}

		//title bar
		$title = util.make('div', {'class':classes.title}, $cal);
		if(!opts.useYearNav){
			util.addClassName($title, classes.disableYearNav);
		}
		util.make('a', {'class':classes.previousYear}, $title);           //previous button
		util.make('a', {'class':classes.previousMonth}, $title);          //previous button
		util.make('a', {'class':classes.nextYear}, $title);               //next button
		util.make('a', {'class':classes.nextMonth}, $title);              //next button
		$caption = util.make('span', {'class':classes.caption}, $title);  //title caption

		//column headers
		$header = util.make('div', {'class':classes.header}, $cal);
		i = 0;
		do {
			$span = util.make('span', {}, $header);
			$span.innerHTML = columnHeaders[i];
		} while (++i < 7);

		//individual day cells
		$days = util.make('div', {'class':classes.days}, $cal);
		i = 0;
		dayNodes = [];
		do {
			if (opts.mode == 'week') {
				if ((i % 7) === 0) {
					$week = util.make('div', {'class': classes.week + ' clearfix'}, $days);
					dayNodes.push($week);
				}
				util.make('span', {}, $week);
			} else {
				dayNodes.push(util.make('span', {}, $days));
			}
		} while (++i < 42);

		//store each calendar view for easy redrawing
		calendars.push({
			caption:$caption,
			days:dayNodes
		});

		if (j) util.make('div', {'class':classes.monthSeparator}, $container);
	}

	self.draw();

	util.addEvent($container, 'mousedown', function (event, target) {
		var clickedDate;
		if (util.hasClassName(target, classes.nextMonth)) {
		//NEXT MONTH BUTTON
			if (!self.disableNext && self.publish('view-changed', self, ['next-month']) !== false) {
				self.viewStartDate.add('months',1);
				self.draw();
			}
			return false;

		} else if (util.hasClassName(target, classes.previousMonth)) {
		//PREVIOUS MONTH BUTTON
			if (!self.disablePreviousMonth && self.publish('view-changed', self, ['previous-month']) !== false) {
				self.viewStartDate.subtract('months',1);
				self.draw();
			}
			return false;

		} else if (util.hasClassName(target, classes.nextYear)) {
		//NEXT MONTH BUTTON
			if (!self.disableNext && self.publish('view-changed', self, ['next-year']) !== false) {
				self.viewStartDate.add('years',1);
				self.draw();
			}
			return false;

		} else if (util.hasClassName(target, classes.previousYear)) {
		//PREVIOUS MONTH BUTTON
			if (!self.disablePreviousMonth && self.publish('view-changed', self, ['previous-year']) !== false) {
				self.viewStartDate.subtract('years',1);
				self.draw();
			}
			return false;

		} else if ( (util.hasClassName(target.parentNode, classes.days) || util.hasClassName(target.parentNode, classes.week)) && util.hasClassName(target, classes.dayActive) && (clickedDate = target.getAttribute('data-date'))) {
		//DAY CLICK
			clickedDate = moment(clickedDate, opts.dayAttributeFormat).hours(12);
			if (self.publish('date-clicked', self, [clickedDate]) !== false) {

				switch (opts.mode) {
					case 'multiple':
						if (!self.addSelected(clickedDate)) self.removeSelected(clickedDate);
						break;
					case 'range':
						self.addSelected(clickedDate);
						break;
					case 'week':
						self.weekSelected(clickedDate);
						break;
					case 'single':
						/* falls through */
					default:
						self.addSelected(clickedDate);
						break;
				}

			}
			return false;

		} else if ( util.hasClassName(target.parentNode, classes.week) && (clickedDate = target.getAttribute('data-date') ) ) {
		//INACTIVE WEEK CLICK
			clickedDate = moment(clickedDate, opts.dayAttributeFormat).hours(12);
			if (self.publish('date-clicked', self, [clickedDate]) !== false) {
				if (opts.mode == 'week') {
					self.weekSelected(clickedDate);
				}
			}
			return false;
		}

		return false;
	});


	if (!!(opts.attachTo = util.$(opts.attachTo))) {
		opts.attachTo.appendChild($container);
	}

};

Kalendae.prototype = {
	defaults : {
		attachTo              :null,            /* the element to attach the root container to. can be string or DOMElement */
		months                :1,               /* total number of months to display side by side */
		weekStart             :0,               /* day to use for the start of the week. 0 is Sunday */
		direction             :'any',           /* past, today-past, any, today-future, future */
		directionScrolling    :true,            /* if a direction other than any is defined, prevent scrolling out of range */
		viewStartDate         :null,            /* date in the month to display.  When multiple months, this is the left most */
		blackout              :null,            /* array of dates, or function to be passed a date */
		selected              :null,            /* dates already selected.  can be string, date, or array of strings or dates. */
		mode                  :'single',        /* single, multiple, range */
		dayOutOfMonthClickable:false,
		format                :null,            /* string used for parsing dates. */
		subscribe             :null,            /* object containing events to subscribe to */

		columnHeaderFormat    :'dd',            /* number of characters to show in the column headers */
		titleFormat           :'MMMM, YYYY',    /* format mask for month titles. See momentjs.com for rules */
		dayNumberFormat       :'D',             /* format mask for individual days */
		dayAttributeFormat    :'YYYY-MM-DD',    /* format mask for the data-date attribute set on every span */
		parseSplitDelimiter   : /,\s*|\s+-\s+/, /* regex to use for splitting multiple dates from a passed string */
		rangeDelimiter        :' - ',           /* string to use between dates when outputting in range mode */
		multipleDelimiter     :', ',            /* string to use between dates when outputting in multiple mode */
		useYearNav            :true,

		dateClassMap          :{}
	},
	classes : {
		container       :'kalendae',
		calendar        :'k-calendar',
		monthFirst      :'k-first-month',
		monthMiddle     :'k-middle-month',
		monthLast       :'k-last-month',
		title           :'k-title',
		previousMonth   :'k-btn-previous-month',
		nextMonth       :'k-btn-next-month',
		previousYear    :'k-btn-previous-year',
		nextYear        :'k-btn-next-year',
		caption         :'k-caption',
		header          :'k-header',
		days            :'k-days',
		week            :'k-week',
		dayOutOfMonth   :'k-out-of-month',
		dayInMonth      :'k-in-month',
		dayActive       :'k-active',
		daySelected     :'k-selected',
		dayInRange      :'k-range',
		dayToday        :'k-today',
		monthSeparator  :'k-separator',
		disablePreviousMonth    :'k-disable-previous-month-btn',
		disableNextMonth        :'k-disable-next-month-btn',
		disablePreviousYear     :'k-disable-previous-year-btn',
		disableNextYear         :'k-disable-next-year-btn',
		disableYearNav          :'k-disable-year-nav'
	},

	disablePreviousMonth: false,
	disableNextMonth: false,
	disablePreviousYear: false,
	disableNextYear: false,

	directions: {
		'past'          :function (date) {return moment(date).startOf('day').yearDay() >= today.yearDay();},
		'today-past'    :function (date) {return moment(date).startOf('day').yearDay() > today.yearDay();},
		'any'           :function (date) {return false;},
		'today-future'  :function (date) {return moment(date).startOf('day').yearDay() < today.yearDay();},
		'future'        :function (date) {return moment(date).startOf('day').yearDay() <= today.yearDay();}
	},

	getSelectedAsDates : function () {
		var out = [];
		var i=0, c = this._sel.length;
		for (;i<c;i++) {
			out.push(this._sel[i].toDate());
		}
		return out;
	},

	getSelectedAsText : function (format) {
		var out = [];
		var i=0, c = this._sel.length;
		for (;i<c;i++) {
			out.push(this._sel[i].format(format || this.settings.format || 'YYYY-MM-DD'));
		}
		return out;
	},

	getSelectedRaw : function () {
		var out = [];
		var i=0, c = this._sel.length;
		for (;i<c;i++) {
			out.push(moment(this._sel[i]));
		}
		return out;
	},

	getSelected : function (format) {
		var sel = this.getSelectedAsText(format);
		switch (this.settings.mode) {
			case 'week':
				/* falls through range */

			case 'range':
				sel.splice(2); //shouldn't be more than two, but lets just make sure.
				return sel.join(this.settings.rangeDelimiter);

			case 'multiple':
				return sel.join(this.settings.multipleDelimiter);

			case 'single':
				/* falls through */
			default:
				return (sel[0] || null);
		}
	},

	isSelected : function (input) {
		input = moment(input).startOf('day').yearDay();
		if (input < 1 || !this._sel || this._sel.length < 1) return false;

		switch (this.settings.mode) {
			case 'week':
				/* falls through range */
			case 'range':
				var a = this._sel[0] ? this._sel[0].startOf('day').yearDay() : 0,
					b = this._sel[1] ? this._sel[1].startOf('day').yearDay() : 0;

				if (a === input || b === input) return 1;
				if (!a || !b) return 0;

				if ((input > a && input < b) || (a<b && input < a && input > b))  return -1;
				return false;

			case 'multiple':
				var i = this._sel.length;
				while (i--) {
					if (this._sel[i].startOf('day').yearDay() === input) {
						return true;
					}
				}
				return false;


			case 'single':
				/* falls through */
			default:
				return (this._sel[0] && (this._sel[0].startOf('day').yearDay() === input));
		}

		return false;
	},

	setSelected : function (input, draw) {
		var i,
			new_dates = parseDates(input, this.settings.parseSplitDelimiter, this.settings.format),
			old_dates = parseDates(this.getSelected(), this.settings.parseSplitDelimiter, this.settings.format);

		i = old_dates.length;
		while(i--) { this.removeSelected(old_dates[i], false); }

		i = new_dates.length;
		while(i--) { this.addSelected(new_dates[i], false); }

		if (draw !== false) {
			if (new_dates[0]) {
				this.viewStartDate = moment(new_dates[0], this.settings.format);
			}
			this.draw();
		}
	},

	addSelected : function (date, draw) {
		date = moment(date, this.settings.format).hours(12);

		if(this.settings.dayOutOfMonthClickable && this.settings.mode !== 'range'){ this.makeSelectedDateVisible(date); }

		switch (this.settings.mode) {
			case 'multiple':
				if (!this.isSelected(date)) this._sel.push(date);
				else return false;
				break;
			case 'range':

				if (this._sel.length !== 1) this._sel = [date];
				else {
					if (date.startOf('day').yearDay() > this._sel[0].startOf('day').yearDay()) this._sel[1] = date;
					else this._sel = [date, this._sel[0]];
				}
				break;
			case 'single':
				/* falls through */
			default:
				this._sel = [date];
				break;
		}
		this._sel.sort(function (a,b) {return a.startOf('day').yearDay() - b.startOf('day').yearDay();});
		this.publish('change', this, [date]);
		if (draw !== false) this.draw();
		return true;
	},

	weekSelected: function (mom) {
		var x = mom.toDate();
		var start = moment(x).startOf('week');
		var end = moment(x).endOf('week').subtract('day',1);
		this._sel = [start, end];
		this.publish('change', this, [mom.day()]);
		this.draw();
	},

	makeSelectedDateVisible: function (date) {
		outOfViewMonth = moment(date).date('1').diff(this.viewStartDate,'months');

		if(outOfViewMonth < 0){
			this.viewStartDate.subtract('months',1);
		}
		else if(outOfViewMonth > 0 && outOfViewMonth >= this.settings.months){
			this.viewStartDate.add('months',1);
		}
	},

	removeSelected : function (date, draw) {
		date = moment(date, this.settings.format).hours(12);
		var i = this._sel.length;
		while (i--) {
			if (this._sel[i].startOf('day').yearDay() === date.startOf('day').yearDay()) {
				this._sel.splice(i,1);
				this.publish('change', this, [date]);
				if (draw !== false) this.draw();
				return true;
			}
		}
		return false;
	},

	draw : function draw() {
		// return;
		var month = moment(this.viewStartDate).startOf('day').hours(12), //force middle of the day to avoid any weird date shifts
			day,
			classes = this.classes,
			cal,
			$span,
			klass,
			i=0, c,
			j=0, k,
			w,
			s,
			dateString,
			opts = this.settings,
			diff;

		c = this.calendars.length;

		do {
			day = moment(month).date(1);
			day.day( day.day() < this.settings.weekStart ? this.settings.weekStart-7 : this.settings.weekStart);
			//if the first day of the month is less than our week start, back up a week

			cal = this.calendars[i];
			cal.caption.innerHTML = month.format(this.settings.titleFormat);
			j = 0;
			w = 0;
			do {
				if (opts.mode == 'week') {
					if (((j % 7) === 0) && (j !== 0)) {
						w++;
					}
					$span = cal.days[w].childNodes[j%7];
				} else {
					$span = cal.days[j];
				}

				klass = [];

				s = this.isSelected(day);

				if (s) klass.push(({'-1':classes.dayInRange,'1':classes.daySelected, 'true':classes.daySelected})[s]);

				if (day.month() != month.month()) klass.push(classes.dayOutOfMonth);
				else klass.push(classes.dayInMonth);

				if (!(this.blackout(day) || this.direction(day) || (day.month() != month.month() && opts.dayOutOfMonthClickable === false)) || s>0) klass.push(classes.dayActive);

				if (day.startOf('day').yearDay() === today.yearDay()) klass.push(classes.dayToday);

				dateString = day.format(this.settings.dayAttributeFormat);
				if (opts.dateClassMap[dateString]) klass.push(opts.dateClassMap[dateString]);

				$span.innerHTML = day.format(opts.dayNumberFormat);
				$span.className = klass.join(' ');
				$span.setAttribute('data-date', dateString);


				day.add('days',1);
			} while (++j < 42);
			month.add('months',1);
		} while (++i < c);

		if (opts.directionScrolling) {
			var diffComparison = moment().startOf('day').hours(12);
			diff = month.diff(diffComparison, 'months', true);

			if (opts.direction === 'today-past' || opts.direction === 'past') {
				if (diff <= 0) {
					this.disableNextMonth = false;
					util.removeClassName(this.container, classes.disableNextMonth);
				} else {
					this.disableNextMonth = true;
					util.addClassName(this.container, classes.disableNextMonth);
				}
			} else if (opts.direction === 'today-future' || opts.direction === 'future') {
				if (diff > opts.months) {
					this.disablePreviousMonth = false;
					util.removeClassName(this.container, classes.disablePreviousMonth);
				} else {
					this.disablePreviousMonth = true;
					util.addClassName(this.container, classes.disablePreviousMonth);
				}
			}

			if (opts.direction === 'today-past' || opts.direction === 'past') {
				if (diff <= -11) {
					this.disableNextYear = false;
					util.removeClassName(this.container, classes.disableNextYear);
				} else {
					this.disableNextYear = true;
					util.addClassName(this.container, classes.disableNextYear);
				}
			} else if (opts.direction==='today-future' || opts.direction==='future') {
				if (diff > (11 + opts.months)) {
					this.disablePreviousYear = false;
					util.removeClassName(this.container, classes.disablePreviousYear);
				} else {
					this.disablePreviousYear = true;
					util.addClassName(this.container, classes.disablePreviousYear);
				}
			}
		}
	}
};

var parseDates = function (input, delimiter, format) {
	var output = [];

	if (typeof input === 'string') {
		input = input.split(delimiter);
	} else if (!util.isArray(input)) {
		input = [input];
	}

	var c = input.length,
		i = 0,
		m;

	do {
		if (input[i]) {
			m = moment(input[i], format).hours(12);
			if (m.isValid()) output.push(m);
		}
	} while (++i < c);

	return output;
};



window.Kalendae = Kalendae;

var util = Kalendae.util = {

	isIE8: function() {
		return !!( (/msie 8./i).test(navigator.appVersion) && !(/opera/i).test(navigator.userAgent) && window.ActiveXObject && XDomainRequest && !window.msPerformance );
	},

// ELEMENT FUNCTIONS

	$: function (elem) {
		return (typeof elem == 'string') ? document.getElementById(elem) : elem;
	},

	$$: function (selector) {
		return document.querySelectorAll(selector);
	},

	make: function (tagName, attributes, attach) {
		var k, e = document.createElement(tagName);
		if (!!attributes) for (k in attributes) if (attributes.hasOwnProperty(k)) e.setAttribute(k, attributes[k]);
		if (!!attach) attach.appendChild(e);
		return e;
	},

	// Returns true if the DOM element is visible, false if it's hidden.
	// Checks if display is anything other than none.
	isVisible: function (elem) {
		// shamelessly copied from jQuery
		return elem.offsetWidth > 0 || elem.offsetHeight > 0;
	},

	getStyle: function (elem, styleProp) {
		var y, s;
		if (elem.currentStyle) {
			y = elem.currentStyle[styleProp];
		} else if (window.getComputedStyle) {
      s = window.getComputedStyle(elem, null);
      y = s ? s[styleProp] : '';
		}
		return y;
	},

	domReady: function (f) {
		var state = document.readyState;
		if (state === 'complete' || state === 'interactive') {
			f();
		} else {
			setTimeout(function() { util.domReady(f); }, 9);
		}
	},

	// Adds a listener callback to a DOM element which is fired on a specified
	// event.  Callback is sent the event object and the element that triggered the event
	addEvent: function (elem, eventName, callback) {
		var listener = function (event) {
			event = event || window.event;
			var target = event.target || event.srcElement;
			var block = callback.apply(elem, [event, target]);
			if (block === false) {
				if (!!event.preventDefault) event.preventDefault();
				else {
					event.returnValue = false;
					event.cancelBubble = true;
				}
			}
			return block;
		};
		if (elem.attachEvent) { // IE only.  The "on" is mandatory.
			elem.attachEvent("on" + eventName, listener);
		} else { // Other browsers.
			elem.addEventListener(eventName, listener, false);
		}
		return listener;
	},

	// Removes a listener callback from a DOM element which is fired on a specified
	// event.
	removeEvent: function (elem, event, listener) {
		if (elem.detachEvent) {	// IE only.  The "on" is mandatory.
			elem.detachEvent("on" + event, listener);
		} else { // Other browsers.
			elem.removeEventListener(event, listener, false);
		}
	},

	fireEvent: function (elem, event) {
		if (document.createEvent) {
			var e = document.createEvent('HTMLEvents');
			e.initEvent(event, false, true);
			elem.dispatchEvent(e);
		} else if (document.createEventObject) {
			elem.fireEvent('on' + event) ;
		} else if (typeof elem['on' + event] == 'function' ) {
			elem['on' + event]();
		}
	},

	hasClassName: function(elem, className) { //copied and modified from Prototype.js
		if (!(elem = util.$(elem))) return false;
		var eClassName = elem.className;
		return (eClassName.length > 0 && (eClassName == className || new RegExp("(^|\\s)" + className + "(\\s|$)").test(eClassName)));
	},

	addClassName: function(elem, className) { //copied and modified from Prototype.js
		if (!(elem = util.$(elem))) return;
		if (!util.hasClassName(elem, className)) elem.className += (elem.className ? ' ' : '') + className;
	},

	removeClassName: function(elem, className) { //copied and modified from Prototype.js
		if (!(elem = util.$(elem))) return;
		elem.className = util.trimString(elem.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' '));
	},

	isFixed: function (elem) {
		do {
			if (util.getStyle(elem, 'position') === 'fixed') return true;
		} while ((elem = elem.offsetParent));
		return false;
	},

	scrollContainer: function (elem) {
		do {
			var overflow = util.getStyle(elem, 'overflow');
			if (overflow === 'auto' || overflow === 'scroll') return elem;
		} while ((elem = elem.parentNode) && elem != window.document.body);
		return null;
	},

	getPosition: function (elem, isInner) {
		var x = elem.offsetLeft,
			y = elem.offsetTop,
			r = {};

		if (!isInner) {
			while ((elem = elem.offsetParent)) {
				x += elem.offsetLeft;
				y += elem.offsetTop;
			}
		}

		r[0] = r.left = x;
		r[1] = r.top = y;
		return r;
	},

	getHeight: function (elem) {
		return elem.offsetHeight || elem.scrollHeight;
	},

	getWidth: function (elem) {
		return elem.offsetWidth || elem.scrollWidth;
	},


// TEXT FUNCTIONS

	trimString: function (input) {
		return input.replace(/^\s+/, '').replace(/\s+$/, '');
	},


// OBJECT FUNCTIONS

	merge: function () {
		/* Combines multiple objects into one.
		 * Syntax: util.extend([true], object1, object2, ... objectN)
		 * If first argument is true, function will merge recursively.
		 */

		var deep = (arguments[0]===true),
			d = {},
			i = deep?1:0;

		var _c = function (a, b) {
			if (typeof b !== 'object') return;
			for (var k in b) if (b.hasOwnProperty(k)) {
				//if property is an object or array, merge the contents instead of overwriting, if extend() was called as such
				if (deep && typeof a[k] === 'object' && typeof b[k] === 'object') _update(a[k], b[k]);
				else a[k] = b[k];
			}
			return a;
		};

		for (; i < arguments.length; i++) {
			_c(d, arguments[i]);
		}
		return d;
	},

	isArray: function (array) {
		return Object.prototype.toString.call(array) == "[object Array]";
	}
};


//auto-initializaiton code
if (typeof document.addEventListener === 'function') Kalendae.util.domReady(function () {
	var els = util.$$('.auto-kal'),
		i = els.length,
		e,
		options,
		optionsRaw;

	while (i--) {
		e = els[i];
		optionsRaw = e.getAttribute('data-kal');
		options = (optionsRaw == null || optionsRaw == "") ? {} : (new Function('return {' + optionsRaw + '};'))();

		if (e.tagName === 'INPUT') {
			//if element is an input, bind a popup calendar to the input.
			new Kalendae.Input(e, options);
		} else {
			//otherwise, insert a flat calendar into the element.
			new Kalendae(util.merge(options, {attachTo:e}));
		}

	}
});
Kalendae.Input = function (targetElement, options) {
	if (typeof document.addEventListener !== 'function'  && !util.isIE8()) return;

	var $input = this.input = util.$(targetElement),
		overwriteInput,
		$closeButton,
		changing = false;

	if (!$input || $input.tagName !== 'INPUT') throw "First argument for Kalendae.Input must be an <input> element or a valid element id.";

	var self = this,
		classes = self.classes,
		opts = self.settings = util.merge(self.defaults, options);

	this._events = {};

	//force attachment to the body
	opts.attachTo = window.document.body;

	//if no override provided, use the input's contents
	if (!opts.selected) opts.selected = $input.value;
	else overwriteInput = true;

	//call our parent constructor
	Kalendae.call(self, opts);

	//create the close button
	if (opts.closeButton) {
		$closeButton = util.make('a', {'class':classes.closeButton}, self.container);
		util.addEvent($closeButton, 'click', function () {
			$input.blur();
		});
	}

	if (overwriteInput) $input.value = self.getSelected();

	var $container = self.container,
		noclose = false;

	$container.style.display = 'none';
	util.addClassName($container, classes.positioned);

	this._events.containerMouseDown = util.addEvent($container, 'mousedown', function (event, target) {
		noclose = true; //IE8 doesn't obey event blocking when it comes to focusing, so we have to do this shit.
	});

	this._events.documentMousedown = util.addEvent(window.document, 'mousedown', function (event, target) {
		noclose = false;
	});

	this._events.inputFocus = util.addEvent($input, 'focus', function () {
		changing = true; // prevent setSelected from altering the input contents.
		self.setSelected(this.value);
		changing = false;
		self.show();
	});

	this._events.inputBlur = util.addEvent($input, 'blur', function () {
		if (noclose && util.isIE8()) {
			noclose = false;
			$input.focus();
		}
		else self.hide();
	});

	this._events.inputKeyup = util.addEvent($input, 'keyup', function (event) {
		changing = true; // prevent setSelected from altering the input contents.
		self.setSelected(this.value);
		changing = false;
	});

	var $scrollContainer = util.scrollContainer($input);

	if( $scrollContainer ) {

		// Hide calendar when $scrollContainer is scrolled
		util.addEvent($scrollContainer, 'scroll', function (event) {
			$input.blur();
		});
	}

	self.subscribe('change', function () {
		if (changing) {
			// the change event came from an internal modification, don't update the field contents
			return;
		}
		$input.value = self.getSelected();
		util.fireEvent($input, 'change');
	});

};

Kalendae.Input.prototype = util.merge(Kalendae.prototype, {
	defaults : util.merge(Kalendae.prototype.defaults, {
		format: 'MM/DD/YYYY',
		side: 'bottom',
		closeButton: true,
		offsetLeft: 0,
		offsetTop: 0
	}),
	classes : util.merge(Kalendae.prototype.classes, {
		positioned : 'k-floating',
		closeButton: 'k-btn-close'
	}),

	show : function () {
		var $container = this.container,
			style = $container.style,
			$input = this.input,
			pos = util.getPosition($input),
			$scrollContainer = util.scrollContainer($input),
			scrollTop = $scrollContainer ? $scrollContainer.scrollTop : 0,
			opts = this.settings;

		style.display = '';
		switch (opts.side) {
			case 'left':
				style.left = (pos.left - util.getWidth($container) + opts.offsetLeft) + 'px';
				style.top  = (pos.top + opts.offsetTop - scrollTop) + 'px';
				break;
			case 'right':
				style.left = (pos.left + util.getWidth($input)) + 'px';
				style.top  = (pos.top + opts.offsetTop - scrollTop) + 'px';
				break;
			case 'top':
				style.left = (pos.left + opts.offsetLeft) + 'px';
				style.top  = (pos.top - util.getHeight($container) + opts.offsetTop - scrollTop) + 'px';
				break;
			case 'bottom':
				/* falls through */
			default:
				style.left = (pos.left + opts.offsetLeft) + 'px';
				style.top  = (pos.top + util.getHeight($input) + opts.offsetTop - scrollTop) + 'px';
				break;
		}

		style.position = util.isFixed($input) ? 'fixed' : 'absolute';

		this.publish('show', this);
	},

	hide : function () {
		this.container.style.display = 'none';
		this.publish('hide', this);
	},

	destroy : function() {
		var $container = this.container;
		var $input = this.input;

		util.removeEvent($container, 'mousedown', this._events.containerMousedown);

		util.removeEvent(window.document, 'mousedown', this._events.documentMousedown);

		util.removeEvent($input, 'focus', this._events.inputFocus);

		util.removeEvent($input, 'blur', this._events.inputBlur);

		util.removeEvent($input, 'keyup', this._events.inputKeyup);

		$container.remove();
	}
});


/*!
* MinPubSub, modified for use on Kalendae
* Copyright(c) 2011 Daniel Lamb <daniellmb.com>
* https://github.com/daniellmb/MinPubSub
* MIT Licensed
*/

var MinPubSub = function(d){

	if (!d) d = this;

	// the topic/subscription hash
	var cache = d.c_ || {}; //check for "c_" cache for unit testing

	d.publish = function(/* String */ topic, /* Object */ target, /* Array? */ args){
		// summary:
		//		Publish some data on a named topic.
		// topic: String
		//		The channel to publish on
		// args: Array?
		//		The data to publish. Each array item is converted into an ordered
		//		arguments on the subscribed functions.
		//
		// example:
		//		Publish stuff on '/some/topic'. Anything subscribed will be called
		//		with a function signature like: function(a,b,c){ ... }
		//
		//		publish("/some/topic", ["a","b","c"]);

		var subs = cache[topic],
			len = subs ? subs.length : 0,
			r;

		//can change loop or reverse array if the order matters
		while(len--){
			r = subs[len].apply(target, args || []);
			if (typeof r === 'boolean') return r;
		}
	};

	d.subscribe = function(/* String */ topic, /* Function */ callback, /* Boolean */ topPriority){
		// summary:
		//		Register a callback on a named topic.
		// topic: String
		//		The channel to subscribe to
		// callback: Function
		//		The handler event. Anytime something is publish'ed on a
		//		subscribed channel, the callback will be called with the
		//		published array as ordered arguments.
		//
		// returns: Array
		//		A handle which can be used to unsubscribe this particular subscription.
		//
		// example:
		//		subscribe("/some/topic", function(a, b, c){ /* handle data */ });

		if(!cache[topic]){
			cache[topic] = [];
		}
		if (topPriority)
			cache[topic].push(callback);
		else
			cache[topic].unshift(callback);
		return [topic, callback]; // Array
	};

	d.unsubscribe = function(/* Array */ handle){
		// summary:
		//		Disconnect a subscribed function for a topic.
		// handle: Array
		//		The return value from a subscribe call.
		// example:
		//		var handle = subscribe("/some/topic", function(){});
		//		unsubscribe(handle);

		var subs = cache[handle[0]],
			callback = handle[1],
			len = subs ? subs.length : 0;

		while(len--){
			if(subs[len] === callback){
				subs.splice(len, 1);
			}
		}
	};

};// moment.js
// version : 2.1.0
// author : Tim Wood
// license : MIT
// momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.1.0",
        round = Math.round, i,
        // internal storage for language config files
        languages = {},

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(\d*)?\.?(\d+)\:(\d+)\:(\d+)\.?(\d{3})?/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO seperator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        // preliminary iso regex
        // 0000-00-00 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000
        isoRegex = /^\s*\d{4}-\d\d-\d\d((T| )(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/,
        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.S', /(T| )\d\d:\d\d:\d\d\.\d{1,3}/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            w : 'week',
            M : 'month',
            y : 'year'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return this.weekYear();
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return this.isoWeekYear();
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return ~~(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(~~(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(~~(a / 60), 2) + ":" + leftZeroFill(~~a % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(~~(10 * a / 6), 4);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            }
        };

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var years = duration.years || duration.year || duration.y || 0,
            months = duration.months || duration.month || duration.M || 0,
            weeks = duration.weeks || duration.week || duration.w || 0,
            days = duration.days || duration.day || duration.d || 0,
            hours = duration.hours || duration.hour || duration.h || 0,
            minutes = duration.minutes || duration.minute || duration.m || 0,
            seconds = duration.seconds || duration.second || duration.s || 0,
            milliseconds = duration.milliseconds || duration.millisecond || duration.ms || 0;

        // store reference to input for deterministic cloning
        this._input = duration;

        // representation for dateAddRemove
        this._milliseconds = milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = months +
            years * 12;

        this._data = {};

        this._bubble();
    }


    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }
        return a;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength) {
        var output = number + '';
        while (output.length < targetLength) {
            output = '0' + output;
        }
        return output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months,
            minutes,
            hours,
            currentDate;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        // store the minutes and hours so we can restore them
        if (days || months) {
            minutes = mom.minute();
            hours = mom.hour();
        }
        if (days) {
            mom.date(mom.date() + days * isAdding);
        }
        if (months) {
            mom.month(mom.month() + months * isAdding);
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom);
        }
        // restore the minutes and hours after possibly changing dst
        if (days || months) {
            mom.minute(minutes);
            mom.hour(hours);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (~~array1[i] !== ~~array2[i]) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        return units ? unitAliases[units] || units.toLowerCase().replace(/(.)s$/, '$1') : units;
    }


    /************************************
        Languages
    ************************************/


    Language.prototype = {
        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },
        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    };

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        if (!key) {
            return moment.fn._lang;
        }
        if (!languages[key] && hasModule) {
            try {
                require('./lang/' + key);
            } catch (e) {
                // call with no params to set to default
                return moment.fn._lang;
            }
        }
        return languages[key];
    }


    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[.*\]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return m.lang().longDateFormat(input) || input;
        }

        while (i-- && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        }

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        switch (token) {
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
            return parseTokenFourDigits;
        case 'YYYYY':
            return parseTokenSixDigits;
        case 'S':
        case 'SS':
        case 'SSS':
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
            return parseTokenOneOrTwoDigits;
        default :
            return new RegExp(token.replace('\\', ''));
        }
    }

    function timezoneMinutesFromString(string) {
        var tzchunk = (parseTokenTimezone.exec(string) || [])[0],
            parts = (tzchunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + ~~parts[2];

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            datePartArray[1] = (input == null) ? 0 : ~~input - 1;
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[1] = a;
            } else {
                config._isValid = false;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DDDD
        case 'DD' : // fall through to DDDD
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                datePartArray[2] = ~~input;
            }
            break;
        // YEAR
        case 'YY' :
            datePartArray[0] = ~~input + (~~input > 68 ? 1900 : 2000);
            break;
        case 'YYYY' :
        case 'YYYYY' :
            datePartArray[0] = ~~input;
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[3] = ~~input;
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[4] = ~~input;
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[5] = ~~input;
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
            datePartArray[6] = ~~ (('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        }

        // if the input is null, the date is not valid
        if (input == null) {
            config._isValid = false;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromArray(config) {
        var i, date, input = [];

        if (config._d) {
            return;
        }

        for (i = 0; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[3] += ~~((config._tzm || 0) / 60);
        input[4] += ~~((config._tzm || 0) % 60);

        date = new Date(0);

        if (config._useUTC) {
            date.setUTCFullYear(input[0], input[1], input[2]);
            date.setUTCHours(input[3], input[4], input[5], input[6]);
        } else {
            date.setFullYear(input[0], input[1], input[2]);
            date.setHours(input[3], input[4], input[5], input[6]);
        }

        config._d = date;
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var tokens = config._f.match(formattingTokens),
            string = config._i,
            i, parsedInput;

        config._a = [];

        for (i = 0; i < tokens.length; i++) {
            parsedInput = (getParseRegexForToken(tokens[i], config).exec(string) || [])[0];
            if (parsedInput) {
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            }
            // don't parse if its not a known token
            if (formatTokenFunctions[tokens[i]]) {
                addTimeToArrayFromToken(tokens[i], parsedInput, config);
            }
        }

        // add remaining unparsed input to the string
        if (string) {
            config._il = string;
        }

        // handle am pm
        if (config._isPm && config._a[3] < 12) {
            config._a[3] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[3] === 12) {
            config._a[3] = 0;
        }
        // return
        dateFromArray(config);
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            tempMoment,
            bestMoment,

            scoreToBeat = 99,
            i,
            currentScore;

        for (i = 0; i < config._f.length; i++) {
            tempConfig = extend({}, config);
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);
            tempMoment = new Moment(tempConfig);

            currentScore = compareArrays(tempConfig._a, tempMoment.toArray());

            // if there is any input that was not parsed
            // add a penalty for that format
            if (tempMoment._il) {
                currentScore += tempMoment._il.length;
            }

            if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempMoment;
            }
        }

        extend(config, bestMoment);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            // match[2] should be "T" or undefined
            config._f = 'YYYY-MM-DD' + (match[2] || " ");
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (parseTokenTimezone.exec(string)) {
                config._f += " Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._d = new Date(string);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromArray(config);
        } else {
            config._d = input instanceof Date ? new Date(+input) : new Date(input);
        }
    }


    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }


    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || input === '') {
            return null;
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = extend({}, input);
            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang) {
        return makeMoment({
            _i : input,
            _f : format,
            _l : lang,
            _isUTC : false
        });
    };

    // creating with utc
    moment.utc = function (input, format, lang) {
        return makeMoment({
            _useUTC : true,
            _isUTC : true,
            _l : lang,
            _i : input,
            _f : format
        });
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var isDuration = moment.isDuration(input),
            isNumber = (typeof input === 'number'),
            duration = (isDuration ? input._input : (isNumber ? {} : input)),
            matched = aspNetTimeSpanJsonRegex.exec(input),
            sign,
            ret;

        if (isNumber) {
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (matched) {
            sign = (matched[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: ~~matched[2] * sign,
                h: ~~matched[3] * sign,
                m: ~~matched[4] * sign,
                s: ~~matched[5] * sign,
                ms: ~~matched[6] * sign
            };
        }

        ret = new Duration(duration);

        if (isDuration && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(key, values);
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment;
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };


    /************************************
        Moment Prototype
    ************************************/


    moment.fn = Moment.prototype = {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            return formatMoment(moment(this).utc(), 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            if (this._isValid == null) {
                if (this._a) {
                    this._isValid = !compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray());
                } else {
                    this._isValid = !isNaN(this._d.getTime());
                }
            }
            return !!this._isValid;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = this._isUTC ? moment(input).zone(this._offset || 0) : moment(input).local(),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            var diff = this.diff(moment().startOf('day'), 'days', true),
                format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            var year = this.year();
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().weekdaysParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : function (input) {
            var utc = this._isUTC ? 'UTC' : '',
                dayOfMonth,
                daysInMonth;

            if (input != null) {
                if (typeof input === 'string') {
                    input = this.lang().monthsParse(input);
                    if (typeof input !== 'number') {
                        return this;
                    }
                }

                dayOfMonth = this.date();
                this.date(1);
                this._d['set' + utc + 'Month'](input);
                this.date(Math.min(dayOfMonth, this.daysInMonth()));

                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + 'Month']();
            }
        },

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            }

            return this;
        },

        endOf: function (units) {
            return this.startOf(units).add(units, 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) === +moment(input).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        zone : function (input) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        daysInMonth : function () {
            return moment.utc([this.year(), this.month() + 1, 0]).date();
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this._d.getDay() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    };

    // helper for adding shortcuts
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + 's'] = function (input) {
            var utc = this._isUTC ? 'UTC' : '';
            if (input != null) {
                this._d['set' + utc + key](input);
                moment.updateOffset(this);
                return this;
            } else {
                return this._d['get' + utc + key]();
            }
        };
    }

    // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)
    for (i = 0; i < proxyGettersAndSetters.length; i ++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);
    }

    // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')
    makeGetterAndSetter('year', 'FullYear');

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    moment.duration.fn = Duration.prototype = {
        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              ~~(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang
    };

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });


    /************************************
        Exposing Moment
    ************************************/


    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    }
    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `moment` as a global object via a string identifier,
        // for Closure Compiler "advanced" mode
        this['moment'] = moment;
    }
    /*global define:false */
    if (typeof define === "function" && define.amd) {
        define("moment", [], function () {
            return moment;
        });
    }
    /************************************
        Exposing Moment
    ************************************/

    this['moment'] = moment;

}).call(typeof Kalendae === 'undefined' ? window : Kalendae);

if (!Kalendae.moment) {
	if (window.moment) {
		Kalendae.moment = window.moment;
	} else {
		throw "Kalendae requires moment.js. You must use kalendae.standalone.js if moment is not available on the page.";
	}
}

moment = Kalendae.moment;

//function to get the total number of days since the epoch.
moment.fn.yearDay = function (input) {
	var yearday = Math.floor(this._d / 86400000);
    return (typeof input === 'undefined') ? yearday :
        this.add({ d : input - yearday });
};

today = Kalendae.moment().startOf('day');

if (typeof jQuery !== 'undefined' && (typeof document.addEventListener === 'function' || util.isIE8())) {
	jQuery.fn.kalendae = function (options) {
		this.each(function (i, e) {
			if (e.tagName === 'INPUT') {
				//if element is an input, bind a popup calendar to the input.
				$(e).data('kalendae', new Kalendae.Input(e, options));
			} else {
				//otherwise, insert a flat calendar into the element.
				$(e).data('kalendae', new Kalendae($.extend({}, {attachTo:e}, options)));
			}
		});
		return this;
	};
}


})();
